// Copyright 2016-2017 Confluent Inc., 2015-2016 Andreas Heider
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Derived from: rdkafka-dotnet, licensed under the 2-clause BSD License.
//
// Refer to LICENSE for more information.

namespace Confluent.Kafka
{
    public class GroupMemberInfo {

        public GroupMemberInfo(string memberId, string clientId, string clientHost, byte[] memberMetadata, byte[] memberAssignment)
        {
            MemberId = memberId;
            ClientId = clientId;
            ClientHost = clientHost;
            MemberMetadata = memberMetadata;
            MemberAssignment = memberAssignment;
        }

        public string MemberId { get; }            /**< Member id (generated by broker) */
        public string ClientId { get; }            /**< Client's \p client.id */
        public string ClientHost { get; }          /**< Client's hostname */

        // TODO: Think about what the object model might look like if we were to ever
        //       add functionality to interpret this byte[] data. Is the below API what
        //       we want? (probably I think)
        public byte[] MemberMetadata { get; }      /**< Member metadata (binary),
                                                         *   format depends on \p protocol_type. */
        public byte[] MemberAssignment { get; }    /**< Member assignment (binary),
                                                         *   format depends on \p protocol_type. */
    }
}
